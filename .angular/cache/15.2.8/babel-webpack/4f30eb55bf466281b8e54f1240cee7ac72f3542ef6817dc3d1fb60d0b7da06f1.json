{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MonitorService = void 0;\nconst interfaces_1 = require(\"../utilities/interfaces\");\nconst _constants = require(\"../utilities/constants-angular\");\nconst operators_1 = require(\"rxjs/operators\");\nconst rxjs_1 = require(\"rxjs\");\nconst i0 = require(\"@angular/core\");\nconst i1 = require(\"ngx-electronyzer\");\nconst i2 = require(\"../schedule/schedule-service\");\nconst i3 = require(\"../configuration/configuration-service\");\nlet MonitorService = /*#__PURE__*/(() => {\n  class MonitorService {\n    constructor(_electronService, _scheduleService, _configurationService) {\n      this._electronService = _electronService;\n      this._scheduleService = _scheduleService;\n      this._configurationService = _configurationService;\n    }\n    getMonitorLog() {\n      let agentSets = new Set();\n      let agentLogMessages = [];\n      let agentLog = [];\n      let lastMessage = null;\n      return (0, rxjs_1.forkJoin)([this._scheduleService.getSchedules(true), this._configurationService.getConfiguration()]).pipe((0, operators_1.map)(results => {\n        this._electronService.ipcRenderer.sendSync('readLogs').map(log => {\n          try {\n            let messages = JSON.parse(log);\n            if (messages.execId != null && messages.scheduleId != null) {\n              messages.str_timestamp = messages.timestamp;\n              messages.timestamp = new Date('' + messages.timestamp);\n              agentLogMessages.push(messages);\n              lastMessage = messages;\n            }\n          } catch (ex) {\n            agentLogMessages.push(new interfaces_1.AgentLogMessage(lastMessage.timestamp, lastMessage.str_timestamp, _constants.CNST_LOGLEVEL.ERROR, lastMessage.system, log, lastMessage.level, lastMessage.execId, lastMessage.scheduleId));\n          }\n        });\n        return agentLogMessages.filter(message1 => {\n          let check = agentSets.has(message1.scheduleId + '|' + message1.execId);\n          agentSets.add(message1.scheduleId + '|' + message1.execId);\n          return !check;\n        }).map(message2 => {\n          let filteredMessages = agentLogMessages.filter(message3 => message2.scheduleId == message3.scheduleId && message2.execId == message3.execId).sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());\n          let startDate = this.findRegex(filteredMessages, '===Início da execução do Agent: (.*)===');\n          let endDate = this.findRegex(filteredMessages, '===Término da execução do Agent: (.*)===');\n          let duration = this.findRegex(filteredMessages, '===Tempo total de execução do Agent: (.*)===');\n          let hasErrors = filteredMessages.find(message2 => message2.loglevel == _constants.CNST_LOGLEVEL.ERROR.tag) != null ? true : false;\n          filteredMessages = filteredMessages.filter(message2 => results[1].debug || message2.loglevel != _constants.CNST_LOGLEVEL.DEBUG.tag);\n          return {\n            scheduleId: message2.scheduleId,\n            scheduleName: results[0].filter(schedule => schedule.id == message2.scheduleId)[0].name,\n            execId: message2.execId,\n            startDate: startDate != null ? new Date(startDate) : null,\n            str_startDate: startDate,\n            endDate: endDate != null ? new Date(endDate) : null,\n            str_endDate: endDate,\n            duration: duration != null ? duration : null,\n            messages: filteredMessages,\n            status: this.setExecutionStatus(hasErrors, endDate)\n          };\n        }).sort((a, b) => b.startDate.getTime() - a.startDate.getTime());\n      }));\n    }\n    setExecutionStatus(hasErrors, endDate) {\n      if (hasErrors) return _constants.CNST_LOGLEVEL.ERROR.level;else if (endDate == null) return _constants.CNST_LOGLEVEL.WARN.level;else return _constants.CNST_LOGLEVEL.INFO.level;\n      return 0;\n    }\n    findRegex(lines, regex) {\n      let regExp = new RegExp(regex);\n      let obj = lines.find(line => {\n        return regExp.test(line.message);\n      });\n      if (obj != null) {\n        let match = obj.message.match(regExp);\n        return match[1];\n      } else {\n        return null;\n      }\n    }\n  }\n  MonitorService.ɵfac = function MonitorService_Factory(t) {\n    return new (t || MonitorService)(i0.ɵɵinject(i1.ElectronService), i0.ɵɵinject(i2.ScheduleService), i0.ɵɵinject(i3.ConfigurationService));\n  };\n  MonitorService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n    token: MonitorService,\n    factory: MonitorService.ɵfac\n  });\n  return MonitorService;\n})();\nexports.MonitorService = MonitorService;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}