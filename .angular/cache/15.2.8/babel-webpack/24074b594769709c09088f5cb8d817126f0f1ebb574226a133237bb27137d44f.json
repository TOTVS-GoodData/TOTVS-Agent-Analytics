{"ast":null,"code":"import * as i0 from '@angular/core';\nimport { inject, ElementRef, Directive, Input, ChangeDetectorRef, forwardRef, Output, ContentChildren, NgModule } from '@angular/core';\nimport { ActiveDescendantKeyManager } from '@angular/cdk/a11y';\nimport { A, hasModifierKey, SPACE, ENTER, HOME, END, UP_ARROW, DOWN_ARROW, LEFT_ARROW, RIGHT_ARROW } from '@angular/cdk/keycodes';\nimport { coerceBooleanProperty, coerceArray } from '@angular/cdk/coercion';\nimport { SelectionModel } from '@angular/cdk/collections';\nimport { Subject, defer, merge } from 'rxjs';\nimport { startWith, switchMap, map, takeUntil, filter } from 'rxjs/operators';\nimport { NG_VALUE_ACCESSOR } from '@angular/forms';\nimport { Directionality } from '@angular/cdk/bidi';\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n/** The next id to use for creating unique DOM IDs. */\nlet nextId = 0;\n/**\n * An implementation of SelectionModel that internally always represents the selection as a\n * multi-selection. This is necessary so that we can recover the full selection if the user\n * switches the listbox from single-selection to multi-selection after initialization.\n *\n * This selection model may report multiple selected values, even if it is in single-selection\n * mode. It is up to the user (CdkListbox) to check for invalid selections.\n */\nclass ListboxSelectionModel extends SelectionModel {\n  constructor(multiple = false, initiallySelectedValues, emitChanges = true, compareWith) {\n    super(true, initiallySelectedValues, emitChanges, compareWith);\n    this.multiple = multiple;\n  }\n  isMultipleSelection() {\n    return this.multiple;\n  }\n  select(...values) {\n    // The super class is always in multi-selection mode, so we need to override the behavior if\n    // this selection model actually belongs to a single-selection listbox.\n    if (this.multiple) {\n      return super.select(...values);\n    } else {\n      return super.setSelection(...values);\n    }\n  }\n}\n/** A selectable option in a listbox. */\nlet CdkOption = /*#__PURE__*/(() => {\n  class CdkOption {\n    constructor() {\n      this._generatedId = `cdk-option-${nextId++}`;\n      this._disabled = false;\n      /** The option's host element */\n      this.element = inject(ElementRef).nativeElement;\n      /** The parent listbox this option belongs to. */\n      this.listbox = inject(CdkListbox);\n      /** Emits when the option is destroyed. */\n      this.destroyed = new Subject();\n      /** Emits when the option is clicked. */\n      this._clicked = new Subject();\n    }\n    /** The id of the option's host element. */\n    get id() {\n      return this._id || this._generatedId;\n    }\n    set id(value) {\n      this._id = value;\n    }\n    /** Whether this option is disabled. */\n    get disabled() {\n      return this.listbox.disabled || this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n    /** The tabindex of the option when it is enabled. */\n    get enabledTabIndex() {\n      return this._enabledTabIndex === undefined ? this.listbox.enabledTabIndex : this._enabledTabIndex;\n    }\n    set enabledTabIndex(value) {\n      this._enabledTabIndex = value;\n    }\n    ngOnDestroy() {\n      this.destroyed.next();\n      this.destroyed.complete();\n    }\n    /** Whether this option is selected. */\n    isSelected() {\n      return this.listbox.isSelected(this);\n    }\n    /** Whether this option is active. */\n    isActive() {\n      return this.listbox.isActive(this);\n    }\n    /** Toggle the selected state of this option. */\n    toggle() {\n      this.listbox.toggle(this);\n    }\n    /** Select this option if it is not selected. */\n    select() {\n      this.listbox.select(this);\n    }\n    /** Deselect this option if it is selected. */\n    deselect() {\n      this.listbox.deselect(this);\n    }\n    /** Focus this option. */\n    focus() {\n      this.element.focus();\n    }\n    /** Get the label for this element which is required by the FocusableOption interface. */\n    getLabel() {\n      return (this.typeaheadLabel ?? this.element.textContent?.trim()) || '';\n    }\n    /**\n     * No-op implemented as a part of `Highlightable`.\n     * @docs-private\n     */\n    setActiveStyles() {}\n    /**\n     * No-op implemented as a part of `Highlightable`.\n     * @docs-private\n     */\n    setInactiveStyles() {}\n    /** Handle focus events on the option. */\n    _handleFocus() {\n      // Options can wind up getting focused in active descendant mode if the user clicks on them.\n      // In this case, we push focus back to the parent listbox to prevent an extra tab stop when\n      // the user performs a shift+tab.\n      if (this.listbox.useActiveDescendant) {\n        this.listbox._setActiveOption(this);\n        this.listbox.focus();\n      }\n    }\n    /** Get the tabindex for this option. */\n    _getTabIndex() {\n      if (this.listbox.useActiveDescendant || this.disabled) {\n        return -1;\n      }\n      return this.isActive() ? this.enabledTabIndex : -1;\n    }\n  }\n  CdkOption.ɵfac = function CdkOption_Factory(t) {\n    return new (t || CdkOption)();\n  };\n  CdkOption.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkOption,\n    selectors: [[\"\", \"cdkOption\", \"\"]],\n    hostAttrs: [\"role\", \"option\", 1, \"cdk-option\"],\n    hostVars: 6,\n    hostBindings: function CdkOption_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"click\", function CdkOption_click_HostBindingHandler($event) {\n          return ctx._clicked.next($event);\n        })(\"focus\", function CdkOption_focus_HostBindingHandler() {\n          return ctx._handleFocus();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"id\", ctx.id);\n        i0.ɵɵattribute(\"aria-selected\", ctx.isSelected())(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled);\n        i0.ɵɵclassProp(\"cdk-option-active\", ctx.isActive());\n      }\n    },\n    inputs: {\n      id: \"id\",\n      value: [\"cdkOption\", \"value\"],\n      typeaheadLabel: [\"cdkOptionTypeaheadLabel\", \"typeaheadLabel\"],\n      disabled: [\"cdkOptionDisabled\", \"disabled\"],\n      enabledTabIndex: [\"tabindex\", \"enabledTabIndex\"]\n    },\n    exportAs: [\"cdkOption\"],\n    standalone: true\n  });\n  return CdkOption;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\nlet CdkListbox = /*#__PURE__*/(() => {\n  class CdkListbox {\n    constructor() {\n      this._generatedId = `cdk-listbox-${nextId++}`;\n      this._disabled = false;\n      this._useActiveDescendant = false;\n      this._orientation = 'vertical';\n      this._navigationWrapDisabled = false;\n      this._navigateDisabledOptions = false;\n      /** Emits when the selected value(s) in the listbox change. */\n      this.valueChange = new Subject();\n      /** The selection model used by the listbox. */\n      this.selectionModel = new ListboxSelectionModel();\n      /** Emits when the listbox is destroyed. */\n      this.destroyed = new Subject();\n      /** The host element of the listbox. */\n      this.element = inject(ElementRef).nativeElement;\n      /** The change detector for this listbox. */\n      this.changeDetectorRef = inject(ChangeDetectorRef);\n      /** Whether the currently selected value in the selection model is invalid. */\n      this._invalid = false;\n      /** The last user-triggered option. */\n      this._lastTriggered = null;\n      /** Callback called when the listbox has been touched */\n      this._onTouched = () => {};\n      /** Callback called when the listbox value changes */\n      this._onChange = () => {};\n      /** Emits when an option has been clicked. */\n      this._optionClicked = defer(() => this.options.changes.pipe(startWith(this.options), switchMap(options => merge(...options.map(option => option._clicked.pipe(map(event => ({\n        option,\n        event\n      }))))))));\n      /** The directionality of the page. */\n      this._dir = inject(Directionality, {\n        optional: true\n      });\n      /** A predicate that skips disabled options. */\n      this._skipDisabledPredicate = option => option.disabled;\n      /** A predicate that does not skip any options. */\n      this._skipNonePredicate = () => false;\n      /** Whether the listbox currently has focus. */\n      this._hasFocus = false;\n    }\n    /** The id of the option's host element. */\n    get id() {\n      return this._id || this._generatedId;\n    }\n    set id(value) {\n      this._id = value;\n    }\n    /** The tabindex to use when the listbox is enabled. */\n    get enabledTabIndex() {\n      return this._enabledTabIndex === undefined ? 0 : this._enabledTabIndex;\n    }\n    set enabledTabIndex(value) {\n      this._enabledTabIndex = value;\n    }\n    /** The value selected in the listbox, represented as an array of option values. */\n    get value() {\n      return this._invalid ? [] : this.selectionModel.selected;\n    }\n    set value(value) {\n      this._setSelection(value);\n    }\n    /**\n     * Whether the listbox allows multiple options to be selected. If the value switches from `true`\n     * to `false`, and more than one option is selected, all options are deselected.\n     */\n    get multiple() {\n      return this.selectionModel.multiple;\n    }\n    set multiple(value) {\n      this.selectionModel.multiple = coerceBooleanProperty(value);\n      if (this.options) {\n        this._updateInternalValue();\n      }\n    }\n    /** Whether the listbox is disabled. */\n    get disabled() {\n      return this._disabled;\n    }\n    set disabled(value) {\n      this._disabled = coerceBooleanProperty(value);\n    }\n    /** Whether the listbox will use active descendant or will move focus onto the options. */\n    get useActiveDescendant() {\n      return this._useActiveDescendant;\n    }\n    set useActiveDescendant(shouldUseActiveDescendant) {\n      this._useActiveDescendant = coerceBooleanProperty(shouldUseActiveDescendant);\n    }\n    /** The orientation of the listbox. Only affects keyboard interaction, not visual layout. */\n    get orientation() {\n      return this._orientation;\n    }\n    set orientation(value) {\n      this._orientation = value === 'horizontal' ? 'horizontal' : 'vertical';\n      if (value === 'horizontal') {\n        this.listKeyManager?.withHorizontalOrientation(this._dir?.value || 'ltr');\n      } else {\n        this.listKeyManager?.withVerticalOrientation();\n      }\n    }\n    /** The function used to compare option values. */\n    get compareWith() {\n      return this.selectionModel.compareWith;\n    }\n    set compareWith(fn) {\n      this.selectionModel.compareWith = fn;\n    }\n    /**\n     * Whether the keyboard navigation should wrap when the user presses arrow down on the last item\n     * or arrow up on the first item.\n     */\n    get navigationWrapDisabled() {\n      return this._navigationWrapDisabled;\n    }\n    set navigationWrapDisabled(wrap) {\n      this._navigationWrapDisabled = coerceBooleanProperty(wrap);\n      this.listKeyManager?.withWrap(!this._navigationWrapDisabled);\n    }\n    /** Whether keyboard navigation should skip over disabled items. */\n    get navigateDisabledOptions() {\n      return this._navigateDisabledOptions;\n    }\n    set navigateDisabledOptions(skip) {\n      this._navigateDisabledOptions = coerceBooleanProperty(skip);\n      this.listKeyManager?.skipPredicate(this._navigateDisabledOptions ? this._skipNonePredicate : this._skipDisabledPredicate);\n    }\n    ngAfterContentInit() {\n      if (typeof ngDevMode === 'undefined' || ngDevMode) {\n        this._verifyNoOptionValueCollisions();\n        this._verifyOptionValues();\n      }\n      this._initKeyManager();\n      // Update the internal value whenever the options or the model value changes.\n      merge(this.selectionModel.changed, this.options.changes).pipe(startWith(null), takeUntil(this.destroyed)).subscribe(() => this._updateInternalValue());\n      this._optionClicked.pipe(filter(({\n        option\n      }) => !option.disabled), takeUntil(this.destroyed)).subscribe(({\n        option,\n        event\n      }) => this._handleOptionClicked(option, event));\n    }\n    ngOnDestroy() {\n      this.listKeyManager?.destroy();\n      this.destroyed.next();\n      this.destroyed.complete();\n    }\n    /**\n     * Toggle the selected state of the given option.\n     * @param option The option to toggle\n     */\n    toggle(option) {\n      this.toggleValue(option.value);\n    }\n    /**\n     * Toggle the selected state of the given value.\n     * @param value The value to toggle\n     */\n    toggleValue(value) {\n      if (this._invalid) {\n        this.selectionModel.clear(false);\n      }\n      this.selectionModel.toggle(value);\n    }\n    /**\n     * Select the given option.\n     * @param option The option to select\n     */\n    select(option) {\n      this.selectValue(option.value);\n    }\n    /**\n     * Select the given value.\n     * @param value The value to select\n     */\n    selectValue(value) {\n      if (this._invalid) {\n        this.selectionModel.clear(false);\n      }\n      this.selectionModel.select(value);\n    }\n    /**\n     * Deselect the given option.\n     * @param option The option to deselect\n     */\n    deselect(option) {\n      this.deselectValue(option.value);\n    }\n    /**\n     * Deselect the given value.\n     * @param value The value to deselect\n     */\n    deselectValue(value) {\n      if (this._invalid) {\n        this.selectionModel.clear(false);\n      }\n      this.selectionModel.deselect(value);\n    }\n    /**\n     * Set the selected state of all options.\n     * @param isSelected The new selected state to set\n     */\n    setAllSelected(isSelected) {\n      if (!isSelected) {\n        this.selectionModel.clear();\n      } else {\n        if (this._invalid) {\n          this.selectionModel.clear(false);\n        }\n        this.selectionModel.select(...this.options.map(option => option.value));\n      }\n    }\n    /**\n     * Get whether the given option is selected.\n     * @param option The option to get the selected state of\n     */\n    isSelected(option) {\n      return this.isValueSelected(option.value);\n    }\n    /**\n     * Get whether the given option is active.\n     * @param option The option to get the active state of\n     */\n    isActive(option) {\n      return !!(this.listKeyManager?.activeItem === option);\n    }\n    /**\n     * Get whether the given value is selected.\n     * @param value The value to get the selected state of\n     */\n    isValueSelected(value) {\n      if (this._invalid) {\n        return false;\n      }\n      return this.selectionModel.isSelected(value);\n    }\n    /**\n     * Registers a callback to be invoked when the listbox's value changes from user input.\n     * @param fn The callback to register\n     * @docs-private\n     */\n    registerOnChange(fn) {\n      this._onChange = fn;\n    }\n    /**\n     * Registers a callback to be invoked when the listbox is blurred by the user.\n     * @param fn The callback to register\n     * @docs-private\n     */\n    registerOnTouched(fn) {\n      this._onTouched = fn;\n    }\n    /**\n     * Sets the listbox's value.\n     * @param value The new value of the listbox\n     * @docs-private\n     */\n    writeValue(value) {\n      this._setSelection(value);\n      this._verifyOptionValues();\n    }\n    /**\n     * Sets the disabled state of the listbox.\n     * @param isDisabled The new disabled state\n     * @docs-private\n     */\n    setDisabledState(isDisabled) {\n      this.disabled = isDisabled;\n    }\n    /** Focus the listbox's host element. */\n    focus() {\n      this.element.focus();\n    }\n    /**\n     * Triggers the given option in response to user interaction.\n     * - In single selection mode: selects the option and deselects any other selected option.\n     * - In multi selection mode: toggles the selected state of the option.\n     * @param option The option to trigger\n     */\n    triggerOption(option) {\n      if (option && !option.disabled) {\n        this._lastTriggered = option;\n        const changed = this.multiple ? this.selectionModel.toggle(option.value) : this.selectionModel.select(option.value);\n        if (changed) {\n          this._onChange(this.value);\n          this.valueChange.next({\n            value: this.value,\n            listbox: this,\n            option: option\n          });\n        }\n      }\n    }\n    /**\n     * Trigger the given range of options in response to user interaction.\n     * Should only be called in multi-selection mode.\n     * @param trigger The option that was triggered\n     * @param from The start index of the options to toggle\n     * @param to The end index of the options to toggle\n     * @param on Whether to toggle the option range on\n     */\n    triggerRange(trigger, from, to, on) {\n      if (this.disabled || trigger && trigger.disabled) {\n        return;\n      }\n      this._lastTriggered = trigger;\n      const isEqual = this.compareWith ?? Object.is;\n      const updateValues = [...this.options].slice(Math.max(0, Math.min(from, to)), Math.min(this.options.length, Math.max(from, to) + 1)).filter(option => !option.disabled).map(option => option.value);\n      const selected = [...this.value];\n      for (const updateValue of updateValues) {\n        const selectedIndex = selected.findIndex(selectedValue => isEqual(selectedValue, updateValue));\n        if (on && selectedIndex === -1) {\n          selected.push(updateValue);\n        } else if (!on && selectedIndex !== -1) {\n          selected.splice(selectedIndex, 1);\n        }\n      }\n      let changed = this.selectionModel.setSelection(...selected);\n      if (changed) {\n        this._onChange(this.value);\n        this.valueChange.next({\n          value: this.value,\n          listbox: this,\n          option: trigger\n        });\n      }\n    }\n    /**\n     * Sets the given option as active.\n     * @param option The option to make active\n     */\n    _setActiveOption(option) {\n      this.listKeyManager.setActiveItem(option);\n    }\n    /** Called when the listbox receives focus. */\n    _handleFocus() {\n      if (!this.useActiveDescendant) {\n        if (this.selectionModel.selected.length > 0) {\n          this._setNextFocusToSelectedOption();\n        } else {\n          this.listKeyManager.setNextItemActive();\n        }\n        this._focusActiveOption();\n      }\n    }\n    /** Called when the user presses keydown on the listbox. */\n    _handleKeydown(event) {\n      if (this._disabled) {\n        return;\n      }\n      const {\n        keyCode\n      } = event;\n      const previousActiveIndex = this.listKeyManager.activeItemIndex;\n      const ctrlKeys = ['ctrlKey', 'metaKey'];\n      if (this.multiple && keyCode === A && hasModifierKey(event, ...ctrlKeys)) {\n        // Toggle all options off if they're all selected, otherwise toggle them all on.\n        this.triggerRange(null, 0, this.options.length - 1, this.options.length !== this.value.length);\n        event.preventDefault();\n        return;\n      }\n      if (this.multiple && (keyCode === SPACE || keyCode === ENTER) && hasModifierKey(event, 'shiftKey')) {\n        if (this.listKeyManager.activeItem && this.listKeyManager.activeItemIndex != null) {\n          this.triggerRange(this.listKeyManager.activeItem, this._getLastTriggeredIndex() ?? this.listKeyManager.activeItemIndex, this.listKeyManager.activeItemIndex, !this.listKeyManager.activeItem.isSelected());\n        }\n        event.preventDefault();\n        return;\n      }\n      if (this.multiple && keyCode === HOME && hasModifierKey(event, ...ctrlKeys) && hasModifierKey(event, 'shiftKey')) {\n        const trigger = this.listKeyManager.activeItem;\n        if (trigger) {\n          const from = this.listKeyManager.activeItemIndex;\n          this.listKeyManager.setFirstItemActive();\n          this.triggerRange(trigger, from, this.listKeyManager.activeItemIndex, !trigger.isSelected());\n        }\n        event.preventDefault();\n        return;\n      }\n      if (this.multiple && keyCode === END && hasModifierKey(event, ...ctrlKeys) && hasModifierKey(event, 'shiftKey')) {\n        const trigger = this.listKeyManager.activeItem;\n        if (trigger) {\n          const from = this.listKeyManager.activeItemIndex;\n          this.listKeyManager.setLastItemActive();\n          this.triggerRange(trigger, from, this.listKeyManager.activeItemIndex, !trigger.isSelected());\n        }\n        event.preventDefault();\n        return;\n      }\n      if (keyCode === SPACE || keyCode === ENTER) {\n        this.triggerOption(this.listKeyManager.activeItem);\n        event.preventDefault();\n        return;\n      }\n      const isNavKey = keyCode === UP_ARROW || keyCode === DOWN_ARROW || keyCode === LEFT_ARROW || keyCode === RIGHT_ARROW || keyCode === HOME || keyCode === END;\n      this.listKeyManager.onKeydown(event);\n      // Will select an option if shift was pressed while navigating to the option\n      if (isNavKey && event.shiftKey && previousActiveIndex !== this.listKeyManager.activeItemIndex) {\n        this.triggerOption(this.listKeyManager.activeItem);\n      }\n    }\n    /** Called when a focus moves into the listbox. */\n    _handleFocusIn() {\n      // Note that we use a `focusin` handler for this instead of the existing `focus` handler,\n      // because focus won't land on the listbox if `useActiveDescendant` is enabled.\n      this._hasFocus = true;\n    }\n    /**\n     * Called when the focus leaves an element in the listbox.\n     * @param event The focusout event\n     */\n    _handleFocusOut(event) {\n      const otherElement = event.relatedTarget;\n      if (this.element !== otherElement && !this.element.contains(otherElement)) {\n        this._onTouched();\n        this._hasFocus = false;\n        this._setNextFocusToSelectedOption();\n      }\n    }\n    /** Get the id of the active option if active descendant is being used. */\n    _getAriaActiveDescendant() {\n      return this._useActiveDescendant ? this.listKeyManager?.activeItem?.id : null;\n    }\n    /** Get the tabindex for the listbox. */\n    _getTabIndex() {\n      if (this.disabled) {\n        return -1;\n      }\n      return this.useActiveDescendant || !this.listKeyManager.activeItem ? this.enabledTabIndex : -1;\n    }\n    /** Initialize the key manager. */\n    _initKeyManager() {\n      this.listKeyManager = new ActiveDescendantKeyManager(this.options).withWrap(!this._navigationWrapDisabled).withTypeAhead().withHomeAndEnd().withAllowedModifierKeys(['shiftKey']).skipPredicate(this._navigateDisabledOptions ? this._skipNonePredicate : this._skipDisabledPredicate);\n      if (this.orientation === 'vertical') {\n        this.listKeyManager.withVerticalOrientation();\n      } else {\n        this.listKeyManager.withHorizontalOrientation(this._dir?.value || 'ltr');\n      }\n      if (this.selectionModel.selected.length) {\n        Promise.resolve().then(() => this._setNextFocusToSelectedOption());\n      }\n      this.listKeyManager.change.subscribe(() => this._focusActiveOption());\n    }\n    /** Focus the active option. */\n    _focusActiveOption() {\n      if (!this.useActiveDescendant) {\n        this.listKeyManager.activeItem?.focus();\n      }\n      this.changeDetectorRef.markForCheck();\n    }\n    /**\n     * Set the selected values.\n     * @param value The list of new selected values.\n     */\n    _setSelection(value) {\n      if (this._invalid) {\n        this.selectionModel.clear(false);\n      }\n      this.selectionModel.setSelection(...this._coerceValue(value));\n      if (!this._hasFocus) {\n        this._setNextFocusToSelectedOption();\n      }\n    }\n    /** Sets the first selected option as first in the keyboard focus order. */\n    _setNextFocusToSelectedOption() {\n      // Null check the options since they only get defined after `ngAfterContentInit`.\n      const selected = this.options?.find(option => option.isSelected());\n      if (selected) {\n        this.listKeyManager.updateActiveItem(selected);\n      }\n    }\n    /** Update the internal value of the listbox based on the selection model. */\n    _updateInternalValue() {\n      const indexCache = new Map();\n      this.selectionModel.sort((a, b) => {\n        const aIndex = this._getIndexForValue(indexCache, a);\n        const bIndex = this._getIndexForValue(indexCache, b);\n        return aIndex - bIndex;\n      });\n      const selected = this.selectionModel.selected;\n      this._invalid = !this.multiple && selected.length > 1 || !!this._getInvalidOptionValues(selected).length;\n      this.changeDetectorRef.markForCheck();\n    }\n    /**\n     * Gets the index of the given value in the given list of options.\n     * @param cache The cache of indices found so far\n     * @param value The value to find\n     * @return The index of the value in the options list\n     */\n    _getIndexForValue(cache, value) {\n      const isEqual = this.compareWith || Object.is;\n      if (!cache.has(value)) {\n        let index = -1;\n        for (let i = 0; i < this.options.length; i++) {\n          if (isEqual(value, this.options.get(i).value)) {\n            index = i;\n            break;\n          }\n        }\n        cache.set(value, index);\n      }\n      return cache.get(value);\n    }\n    /**\n     * Handle the user clicking an option.\n     * @param option The option that was clicked.\n     */\n    _handleOptionClicked(option, event) {\n      event.preventDefault();\n      this.listKeyManager.setActiveItem(option);\n      if (event.shiftKey && this.multiple) {\n        this.triggerRange(option, this._getLastTriggeredIndex() ?? this.listKeyManager.activeItemIndex, this.listKeyManager.activeItemIndex, !option.isSelected());\n      } else {\n        this.triggerOption(option);\n      }\n    }\n    /** Verifies that no two options represent the same value under the compareWith function. */\n    _verifyNoOptionValueCollisions() {\n      this.options.changes.pipe(startWith(this.options), takeUntil(this.destroyed)).subscribe(() => {\n        const isEqual = this.compareWith ?? Object.is;\n        for (let i = 0; i < this.options.length; i++) {\n          const option = this.options.get(i);\n          let duplicate = null;\n          for (let j = i + 1; j < this.options.length; j++) {\n            const other = this.options.get(j);\n            if (isEqual(option.value, other.value)) {\n              duplicate = other;\n              break;\n            }\n          }\n          if (duplicate) {\n            // TODO(mmalerba): Link to docs about this.\n            if (this.compareWith) {\n              console.warn(`Found multiple CdkOption representing the same value under the given compareWith function`, {\n                option1: option.element,\n                option2: duplicate.element,\n                compareWith: this.compareWith\n              });\n            } else {\n              console.warn(`Found multiple CdkOption with the same value`, {\n                option1: option.element,\n                option2: duplicate.element\n              });\n            }\n            return;\n          }\n        }\n      });\n    }\n    /** Verifies that the option values are valid. */\n    _verifyOptionValues() {\n      if (this.options && (typeof ngDevMode === 'undefined' || ngDevMode)) {\n        const selected = this.selectionModel.selected;\n        const invalidValues = this._getInvalidOptionValues(selected);\n        if (!this.multiple && selected.length > 1) {\n          throw Error('Listbox cannot have more than one selected value in multi-selection mode.');\n        }\n        if (invalidValues.length) {\n          throw Error('Listbox has selected values that do not match any of its options.');\n        }\n      }\n    }\n    /**\n     * Coerces a value into an array representing a listbox selection.\n     * @param value The value to coerce\n     * @return An array\n     */\n    _coerceValue(value) {\n      return value == null ? [] : coerceArray(value);\n    }\n    /**\n     * Get the sublist of values that do not represent valid option values in this listbox.\n     * @param values The list of values\n     * @return The sublist of values that are not valid option values\n     */\n    _getInvalidOptionValues(values) {\n      const isEqual = this.compareWith || Object.is;\n      const validValues = (this.options || []).map(option => option.value);\n      return values.filter(value => !validValues.some(validValue => isEqual(value, validValue)));\n    }\n    /** Get the index of the last triggered option. */\n    _getLastTriggeredIndex() {\n      const index = this.options.toArray().indexOf(this._lastTriggered);\n      return index === -1 ? null : index;\n    }\n  }\n  CdkListbox.ɵfac = function CdkListbox_Factory(t) {\n    return new (t || CdkListbox)();\n  };\n  CdkListbox.ɵdir = /* @__PURE__ */i0.ɵɵdefineDirective({\n    type: CdkListbox,\n    selectors: [[\"\", \"cdkListbox\", \"\"]],\n    contentQueries: function CdkListbox_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        i0.ɵɵcontentQuery(dirIndex, CdkOption, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        i0.ɵɵqueryRefresh(_t = i0.ɵɵloadQuery()) && (ctx.options = _t);\n      }\n    },\n    hostAttrs: [\"role\", \"listbox\", 1, \"cdk-listbox\"],\n    hostVars: 6,\n    hostBindings: function CdkListbox_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        i0.ɵɵlistener(\"focus\", function CdkListbox_focus_HostBindingHandler() {\n          return ctx._handleFocus();\n        })(\"keydown\", function CdkListbox_keydown_HostBindingHandler($event) {\n          return ctx._handleKeydown($event);\n        })(\"focusout\", function CdkListbox_focusout_HostBindingHandler($event) {\n          return ctx._handleFocusOut($event);\n        })(\"focusin\", function CdkListbox_focusin_HostBindingHandler() {\n          return ctx._handleFocusIn();\n        });\n      }\n      if (rf & 2) {\n        i0.ɵɵhostProperty(\"id\", ctx.id);\n        i0.ɵɵattribute(\"tabindex\", ctx._getTabIndex())(\"aria-disabled\", ctx.disabled)(\"aria-multiselectable\", ctx.multiple)(\"aria-activedescendant\", ctx._getAriaActiveDescendant())(\"aria-orientation\", ctx.orientation);\n      }\n    },\n    inputs: {\n      id: \"id\",\n      enabledTabIndex: [\"tabindex\", \"enabledTabIndex\"],\n      value: [\"cdkListboxValue\", \"value\"],\n      multiple: [\"cdkListboxMultiple\", \"multiple\"],\n      disabled: [\"cdkListboxDisabled\", \"disabled\"],\n      useActiveDescendant: [\"cdkListboxUseActiveDescendant\", \"useActiveDescendant\"],\n      orientation: [\"cdkListboxOrientation\", \"orientation\"],\n      compareWith: [\"cdkListboxCompareWith\", \"compareWith\"],\n      navigationWrapDisabled: [\"cdkListboxNavigationWrapDisabled\", \"navigationWrapDisabled\"],\n      navigateDisabledOptions: [\"cdkListboxNavigatesDisabledOptions\", \"navigateDisabledOptions\"]\n    },\n    outputs: {\n      valueChange: \"cdkListboxValueChange\"\n    },\n    exportAs: [\"cdkListbox\"],\n    standalone: true,\n    features: [i0.ɵɵProvidersFeature([{\n      provide: NG_VALUE_ACCESSOR,\n      useExisting: forwardRef(() => CdkListbox),\n      multi: true\n    }])]\n  });\n  return CdkListbox;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nconst EXPORTED_DECLARATIONS = [CdkListbox, CdkOption];\nlet CdkListboxModule = /*#__PURE__*/(() => {\n  class CdkListboxModule {}\n  CdkListboxModule.ɵfac = function CdkListboxModule_Factory(t) {\n    return new (t || CdkListboxModule)();\n  };\n  CdkListboxModule.ɵmod = /* @__PURE__ */i0.ɵɵdefineNgModule({\n    type: CdkListboxModule\n  });\n  CdkListboxModule.ɵinj = /* @__PURE__ */i0.ɵɵdefineInjector({});\n  return CdkListboxModule;\n})();\n/*#__PURE__*/(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { CdkListbox, CdkListboxModule, CdkOption };\n//# sourceMappingURL=listbox.mjs.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}